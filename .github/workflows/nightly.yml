name: Nightly smokes (v1.0.0-rc.1)

on:
  push:
    branches: [ main ]
  schedule:
    - cron: '0 2 * * *'  # 02:00 UTC nightly
  workflow_dispatch:
    inputs:
      run_mcp_checks:
        description: "Run MCP websocket progress + TLS checks"
        required: false
        default: "false"
      run_golden:
        description: "Run full golden + coverage suite"
        required: false
        default: "false"

jobs:
  guard:
    if: ${{ github.event_name == 'push' }}
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Nightly smokes only run via schedule or workflow_dispatch (current: $GITHUB_EVENT_NAME)"

  smokes:
    if: ${{ github.event_name == 'workflow_dispatch' || github.event_name == 'schedule' }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    env:
      LEXON_SEED: "0"
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Use Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            v1.0.0-rc.1

      - name: Build
        run: |
          cargo build -p lexc -p lexc-cli

      - name: Run smokes
        id: smokes
        shell: bash
        run: |
          set -euo pipefail
          TS=$(date +%s)
          LOGDIR="/tmp/lexon_rc1_ci_${TS}"
          mkdir -p "$LOGDIR"

          SAMPLES=(
            samples/00-hello-lexon.lx
            samples/01-async-parallel.lx
            samples/release-notes-copilot/main.lx
            samples/data-quality/main.lx
            samples/eval-harness/main.lx
            samples/static-site/main.lx
            samples/triage/main.lx
            samples/sessions/main.lx
          )

          failures=0
          for s in "${SAMPLES[@]}"; do
            name=$(basename "$s" .lx)
            log="$LOGDIR/${name}.log"
            echo "[RUN] $s" | tee "$log"
            if ! cargo run -q -p lexc-cli -- compile --run "$s" >> "$log" 2>&1; then
              echo "[FAIL] $s" | tee -a "$log"
              failures=$((failures+1))
            else
              echo "[OK] $s" | tee -a "$log"
            fi
          done

          echo "logdir=$LOGDIR" >> "$GITHUB_OUTPUT"
          if [[ "$failures" -ne 0 ]]; then
            echo "One or more smokes failed ($failures). See logs." >&2
            exit 1
          fi

      - name: MCP WS progress check
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.run_mcp_checks == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          # Start WS server in background with stream+heartbeat
          LEXON_MCP_WS_ADDR=127.0.0.1:8094 LEXON_MCP_HEARTBEAT_MS=100 LEXON_MCP_STREAM=1 ./target/debug/lexc --mcp-ws &>/tmp/lexon_ws_ci.log &
          srv=$!
          sleep 0.3
          # Run the WS client against it
          out=$(WS_URL=ws://127.0.0.1:8094 cargo run -q -p lexc --bin ws_client)
          echo "$out"
          # Assert we saw at least one progress and a final result
          echo "$out" | grep -q '"method":"progress"' || { echo "No WS progress event seen"; kill $srv || true; exit 1; }
          echo "$out" | grep -q '"result":{"name":"web.search"' || { echo "No WS result seen"; kill $srv || true; exit 1; }
          kill $srv || true
          wait $srv 2>/dev/null || true

      - name: Upload logs
        if: ${{ always() && steps.smokes.outputs.logdir != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: rc1-smokes-logs-${{ matrix.os }}
          path: ${{ steps.smokes.outputs.logdir }}
          if-no-files-found: ignore

      - name: MCP WS TLS/mTLS smoke
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.run_mcp_checks == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          # TLS (self-signed) handshake and ready banner check (script includes timeout)
          zsh scripts/mcp_ws_tls_smoke.sh
          # mTLS (client cert) handshake using openssl s_client (script includes timeout)
          zsh scripts/mcp_ws_mtls_smoke.sh

  golden:
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    env:
      LEXON_SEED: "0"
    needs: smokes
    if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.run_golden == 'true' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Use Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            v1.0.0-rc.1

      - name: Build
        run: cargo build -p lexc -p lexc-cli

      - name: Run golden comparisons
        shell: bash
        run: |
          set -euo pipefail
          declare -A MAP
          MAP[golden/mcp/stdio_oneshot.txt]=samples/mcp/stdio_oneshot.lx
          MAP[golden/mcp/ws_ping.txt]=samples/mcp/ws_ping.lx
          MAP[golden/mcp/ws_server_oneshot.txt]=samples/mcp/ws_server_oneshot.lx
          MAP[golden/rag/hybrid_search.txt]=samples/rag/hybrid_search.lx
          MAP[golden/sessions/main.txt]=samples/sessions/main.lx
          MAP[golden/agents/basic.txt]=samples/agents/basic.lx
          MAP[golden/agents/supervisor.txt]=samples/agents/supervisor.lx
          MAP[golden/validation/ask_with_validation.txt]=samples/validation/ask_with_validation.lx
          MAP[golden/routing/metrics.txt]=samples/routing/metrics.lx
          MAP[golden/routing/v2_smoke.txt]=samples/routing/v2_smoke.lx
          MAP[golden/cache/invalidate_prefix.txt]=samples/cache/invalidate_prefix.lx
          MAP[golden/cache/dist_cache.txt]=samples/cache/dist_cache.lx
          MAP[golden/fixtures/json_roundtrip.txt]=samples/fixtures/json_roundtrip.lx
          MAP[golden/memory/prune_by_metadata.txt]=samples/memory/prune_by_metadata.lx
          MAP[golden/sessions/list_delete.txt]=samples/sessions/list_delete.lx
          MAP[golden/sessions/gc_now.txt]=samples/sessions/gc_now.lx
          MAP[golden/streaming/multioutput.txt]=samples/streaming/multioutput.lx
          MAP[golden/streaming/multioutput_two.txt]=samples/streaming/multioutput_two.lx
          MAP[golden/fixtures/save_load.txt]=samples/fixtures/save_load.lx
          MAP[golden/metrics/write_json.txt]=samples/metrics/write_json.lx
          MAP[golden/prompts/register_render.txt]=samples/prompts/register_render.lx
          MAP[golden/eval/bleu_rouge.txt]=samples/eval/bleu_rouge.lx
          MAP[golden/quality/schema_gate.txt]=samples/quality/schema_gate.lx
          MAP[golden/quality/pii_gate.txt]=samples/quality/pii_gate.lx
          # RAG new goldens
          MAP[golden/rag/opt_window.txt]=samples/rag/opt_window.lx
          MAP[golden/rag/tokenize_smoke.txt]=samples/rag/tokenize_smoke.lx
          MAP[golden/rag/rerank_cross_encoder_smoke.txt]=samples/rag/rerank_cross_encoder_smoke.lx
          MAP[golden/rag/hybrid_page_smoke.txt]=samples/rag/hybrid_page_smoke.lx
          MAP[golden/rag/semantic_fusion_smoke.txt]=samples/rag/semantic_fusion_smoke.lx
          MAP[golden/rag/hybrid_llm_rerank.txt]=samples/rag/hybrid_llm_rerank.lx
          MAP[golden/rag/hybrid_all_smoke.txt]=samples/rag/hybrid_all_smoke.lx
          MAP[golden/rag/fusion_citations_smoke.txt]=samples/rag/fusion_citations_smoke.lx
          MAP[golden/oo/struct_enum_smoke.txt]=samples/oo/struct_enum_smoke.lx
          MAP[golden/lang/top_level_temps.txt]=samples/lang/top_level_temps.lx
          MAP[golden/oo/impl_flatten_smoke.txt]=samples/oo/impl_flatten_smoke.lx
          MAP[golden/oo/instance_method_smoke.txt]=samples/oo/instance_method_smoke.lx
          MAP[golden/oo/module_ns_smoke.txt]=samples/oo/module_ns_smoke.lx
          MAP[golden/oo/trait_enforce_warn.txt]=samples/oo/trait_enforce_warn.lx
          MAP[golden/modules_demo.txt]=samples/modules/golden_smoke.lx
          MAP[golden/oo/receiver_expr.txt]=samples/oo/receiver_expr_golden.lx
          MAP[golden/modules_alias_demo.txt]=samples/modules/alias_demo.lx
          MAP[golden/stdlib_encoding.txt]=samples/stdlib/encoding.lx
          MAP[golden/stdlib_strings.txt]=samples/stdlib/strings.lx
          MAP[golden/stdlib_math.txt]=samples/stdlib/math.lx
          MAP[golden/stdlib_regex_time_crypto.txt]=samples/stdlib/regex_time_crypto.lx

          normalize() {
            sed -E \
              -e 's/\x1B\[[0-9;]*[mK]//g' \
              -e 's/^\[DEBUG\].*$//g' \
              -e 's/^\[INFO\].*$//g' \
              -e 's/Completed in [0-9\.]+s/Completed in <TIME>/g' \
              -e 's/[0-9]{4}-[0-9]{2}-[0-9]{2}.*//g' \
              -e 's/"last_checked_epoch":[0-9]+/"last_checked_epoch":<EPOCH>/g' \
              -e 's/"next_probe_epoch":[0-9]+/"next_probe_epoch":<EPOCH>/g' \
              -e 's/"failure_count":[0-9]+/"failure_count":<NUM>/g' \
              -e 's/,"last_decision":\{.*\}//g' \
              -e '/^\[ROUTING\]/d' \
              -e 's/"bytes":[0-9]+/"bytes":<NUM>/g' \
              -e 's/"written":[0-9]+/"written":<NUM>/g' \
              -e 's/"total":[0-9]+/"total":<NUM>/g' \
              -e 's/^ðŸ’° Estimated cost.*$//g' \
              -e 's/^ðŸ“Š Token usage.*$//g' \
              -e 's/^\s+- .*tokens:.*$//g'
          }

          failures=0
          total=0
          for snap in "${!MAP[@]}"; do
            sample=${MAP[$snap]}
            out=$(mktemp)
            total=$((total+1))
            if [[ "$sample" == "samples/routing/v2_smoke.lx" ]]; then
              if ! LEXON_ROUTING_POLICY=v2 LEXON_PROVIDER_CAPACITY="openai=0,anthropic=0,google=0" LEXON_PROVIDER_BUDGETS="openai=0,anthropic=0,google=0" LEXON_LLM_EST_COST_USD=0.01 cargo run -q -p lexc-cli -- compile --run "$sample" | normalize > "$out"; then
                echo "[RUN FAIL] $sample" >&2
                failures=$((failures+1))
                continue
              fi
            else
              if ! cargo run -q -p lexc-cli -- compile --run "$sample" | normalize > "$out"; then
                echo "[RUN FAIL] $sample" >&2
                failures=$((failures+1))
                continue
              fi
            fi
            if ! normalize < "$snap" | diff -u - "$out" > /tmp/diff.txt; then
              echo "[DIFF FAIL] $sample vs $snap" >&2
              cat /tmp/diff.txt >&2
              failures=$((failures+1))
            else
              echo "[OK] $sample"
            fi
          done
          passed=$((total-failures))
          echo "Golden coverage: $passed/$total"
          echo "{\"total\":$total,\"passed\":$passed,\"failed\":$failures}" > /tmp/golden_coverage.json
          if [[ $failures -ne 0 ]]; then
            echo "$failures golden mismatches" >&2
            exit 1
          fi

      - name: Strict trait negative check
        shell: bash
        run: |
          set -euo pipefail
          if LEXON_TRAIT_ENFORCE=1 cargo run -q -p lexc-cli -- compile --run samples/oo/trait_enforce_error.lx; then
            echo "Expected strict trait failure but sample succeeded" >&2
            exit 1
          else
            echo "Strict trait negative: OK (failed as expected)"
          fi

      - name: Metrics thresholds
        shell: bash
        run: |
          set -euo pipefail
          cargo run -q -p lexc-cli -- compile --run samples/metrics/write_json.lx
          python3 - <<'PY'
          import json
          import sys

          with open('samples/metrics/summary.json') as f:
              js = json.load(f)

          calls = int(js.get('total_llm_calls', 0))
          lat_ms = int(js.get('llm_total_ms', 0))
          cost = float(js.get('total_cost_usd', 0.0)) if 'total_cost_usd' in js else 0.0

          thr_calls = 50
          thr_lat = 60000
          thr_cost = 5.0

          ok = (calls <= thr_calls) and (lat_ms <= thr_lat) and (cost <= thr_cost)
          print(f"metrics: calls={calls} lat_ms={lat_ms} cost={cost} (thresholds: {thr_calls},{thr_lat},{thr_cost})")
          sys.exit(0 if ok else 2)
          PY

      - name: Coverage (llvm-cov)
        shell: bash
        run: |
          set -euo pipefail
          path=$(bash scripts/coverage.sh)
          echo "coverage_path=${path}" >> "$GITHUB_OUTPUT"
        id: cov

      - name: Upload coverage (lcov)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: rc1-coverage-lcov
          path: ${{ steps.cov.outputs.coverage_path }}
          if-no-files-found: ignore

      - name: Bench (compile+run samples)
        shell: bash
        run: |
          set -euo pipefail
          path=$(bash scripts/bench_smoke.sh)
          echo "bench_path=${path}" >> "$GITHUB_OUTPUT"
        id: bench

      - name: Upload bench results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: rc1-bench
          path: ${{ steps.bench.outputs.bench_path }}
          if-no-files-found: ignore

      - name: Upload golden coverage
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: rc1-golden-coverage
          path: /tmp/golden_coverage.json
          if-no-files-found: ignore
