//! # LEXON Intermediate Representation (LexIR) v0.3
//!
//! This module defines the complete intermediate representation for LEXON programs,
//! serving as the bridge between high-level HIR and executable code.
//!
//! ## Overview
//!
//! LexIR is a low-level, typed intermediate representation that captures all
//! semantic information needed for code generation and execution. It provides:
//!
//! - **Type Safety**: Complete type information for all values and operations
//! - **Async Support**: Native async/await constructs for LLM operations
//! - **Memory Management**: Contextual memory and session management
//! - **Data Processing**: Built-in data manipulation and transformation
//! - **LLM Integration**: First-class support for LLM operations
//!
//! ## Architecture
//!
//! The IR is organized into several key components:
//!
//! - [`LexProgram`]: Root container for all program elements
//! - [`LexInstruction`]: Individual executable operations
//! - [`LexExpression`]: Value-producing expressions
//! - [`LexType`]: Type system definitions
//! - [`ValueRef`]: Reference system for values and temporaries
//!
//! ## Example
//!
//! ```rust
//! use lexc::lexir::*;
//!
//! let mut program = LexProgram::new();
//! program.add_instruction(LexInstruction::Assign {
//!     result: ValueRef::Named("x".to_string()),
//!     expr: LexExpression::Value(ValueRef::Literal(LexLiteral::Integer(42))),
//! });
//! ```

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

// ============================================================================
// CORE TYPES AND IDENTIFIERS
// ============================================================================

/// Unique identifier for a temporary variable in LexIR.
///
/// Temporary variables are generated by the compiler during HIR to LexIR
/// conversion to hold intermediate values and computation results.
///
/// # Example
/// ```rust
/// use lexc::lexir::TempId;
/// let temp = TempId(1);
/// ```
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TempId(pub u32);

/// Reference to a value in the program.
///
/// Values can be user-defined variables, compiler-generated temporaries,
/// or embedded literal values. This enum provides a unified way to
/// reference any value in the program.
///
/// # Examples
/// ```rust
/// use lexc::lexir::{ValueRef, TempId, LexLiteral};
///
/// // User variable
/// let var = ValueRef::Named("user_input".to_string());
///
/// // Compiler temporary
/// let temp = ValueRef::Temp(TempId(1));
///
/// // Literal value
/// let lit = ValueRef::Literal(LexLiteral::String("hello".to_string()));
/// ```
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ValueRef {
    /// User-defined named variable
    Named(String),
    /// Temporary value generated by the compiler
    Temp(TempId),
    /// Embedded literal value
    Literal(LexLiteral),
}

// ============================================================================
// LITERAL VALUES
// ============================================================================

/// Literal values in LexIR.
///
/// Represents compile-time known values that can be embedded directly
/// in the intermediate representation. All literals are immutable and
/// type-safe.
///
/// # Type Mapping
/// - `Integer` ‚Üí `LexType::Int`
/// - `Float` ‚Üí `LexType::Float`  
/// - `String` ‚Üí `LexType::String`
/// - `Boolean` ‚Üí `LexType::Bool`
/// - `Array` ‚Üí `LexType::List<T>`
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum LexLiteral {
    /// 64-bit signed integer
    Integer(i64),
    /// 64-bit floating point number
    Float(f64),
    /// UTF-8 string
    String(String),
    /// Boolean value
    Boolean(bool),
    /// Homogeneous array of literals
    Array(Vec<LexLiteral>),
}

impl Eq for LexLiteral {}

impl std::hash::Hash for LexLiteral {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        core::mem::discriminant(self).hash(state);
        match self {
            LexLiteral::Integer(i) => i.hash(state),
            LexLiteral::Float(f) => {
                // Use canonical representation of f64 for hash
                let bits = f.to_bits();
                bits.hash(state);
            }
            LexLiteral::String(s) => s.hash(state),
            LexLiteral::Boolean(b) => b.hash(state),
            LexLiteral::Array(arr) => {
                arr.len().hash(state);
                for item in arr {
                    item.hash(state);
                }
            }
        }
    }
}

// ============================================================================
// TYPE SYSTEM
// ============================================================================

/// Type information for values in LexIR.
///
/// The type system provides complete type information for all values,
/// enabling type checking, optimization, and safe code generation.
///
/// # Design Principles
/// - **Explicit**: All types are explicitly represented
/// - **Compositional**: Complex types built from primitives
/// - **Extensible**: Support for user-defined schema types
/// - **Nullable**: Optional types for safe null handling
///
/// # Examples
/// ```rust
/// use lexc::lexir::LexType;
///
/// // Primitive types
/// let int_type = LexType::Int;
/// let string_type = LexType::String;
///
/// // Complex types
/// let list_type = LexType::List(Box::new(LexType::String));
/// let optional_type = LexType::Option(Box::new(LexType::Int));
/// ```
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum LexType {
    /// 64-bit signed integer
    Int,
    /// 64-bit floating point number
    Float,
    /// UTF-8 string
    String,
    /// Boolean value
    Bool,
    /// User-defined schema type
    Schema(String),
    /// Dataset type with optional schema
    Dataset {
        /// Optional schema name for validation
        schema: Option<String>,
    },
    /// Homogeneous list of values
    List(Box<LexType>),
    /// Key-value map
    Map(Box<LexType>, Box<LexType>),
    /// Optional value (nullable)
    Option(Box<LexType>),
    /// Void type for functions without return value
    Void,
    /// Unknown or inferred type (temporary during compilation)
    Inferred,
}

// ============================================================================
// PROGRAM STRUCTURE
// ============================================================================

/// Complete LexIR program representation.
///
/// This is the root structure that contains all elements of a compiled
/// LEXON program, including instructions, type information, schemas,
/// and function definitions.
///
/// # Components
/// - **Instructions**: Sequential list of executable operations
/// - **Types**: Type information for all values and temporaries
/// - **Schemas**: User-defined data structure definitions
/// - **Functions**: Function definitions with typed parameters
///
/// # Example
/// ```rust
/// use lexc::lexir::LexProgram;
///
/// let mut program = LexProgram::new();
/// // Add instructions, schemas, functions...
/// let json = program.to_json().expect("serialization failed");
/// ```
#[derive(Debug, Serialize, Deserialize)]
pub struct LexProgram {
    /// Sequential program instructions
    pub instructions: Vec<LexInstruction>,
    /// Type table for variables and temporaries
    pub types: HashMap<ValueRef, LexType>,
    /// Schema definitions
    pub schemas: HashMap<String, LexSchemaDefinition>,
    /// Function definitions
    pub functions: HashMap<String, LexFunction>,
}

// ============================================================================
// FUNCTIONS AND SCHEMAS
// ============================================================================

/// Function definition in LexIR.
///
/// Represents a user-defined function with typed parameters and return value.
/// Functions are first-class values and can be called recursively.
///
/// # Example
/// ```rust
/// use lexc::lexir::{LexFunction, LexType};
///
/// let func = LexFunction {
///     name: "add_numbers".to_string(),
///     return_type: LexType::Int,
///     parameters: vec![
///         ("a".to_string(), LexType::Int),
///         ("b".to_string(), LexType::Int),
///     ],
///     body: vec![], // Instructions would go here
/// };
/// ```
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct LexFunction {
    /// Function name
    pub name: String,
    /// Return type
    pub return_type: LexType,
    /// Typed parameters
    pub parameters: Vec<(String, LexType)>,
    /// Function body instructions
    pub body: Vec<LexInstruction>,
}

/// Schema definition for structured data.
///
/// Schemas define the structure and types of complex data objects,
/// enabling type-safe data manipulation and validation.
///
/// # Example
/// ```rust
/// use lexc::lexir::{LexSchemaDefinition, LexSchemaField, LexType};
///
/// let schema = LexSchemaDefinition {
///     name: "User".to_string(),
///     fields: vec![
///         LexSchemaField {
///             name: "id".to_string(),
///             field_type: LexType::Int,
///             is_optional: false,
///             default_value: None,
///         },
///         LexSchemaField {
///             name: "name".to_string(),
///             field_type: LexType::String,
///             is_optional: false,
///             default_value: None,
///         },
///     ],
/// };
/// ```
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct LexSchemaDefinition {
    /// Schema name
    pub name: String,
    /// Field definitions
    pub fields: Vec<LexSchemaField>,
}

/// Field definition within a schema.
///
/// Defines a single field in a schema with its type, optionality,
/// and default value.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct LexSchemaField {
    /// Field name
    pub name: String,
    /// Field type
    pub field_type: LexType,
    /// Whether the field is optional
    pub is_optional: bool,
    /// Default value for optional fields
    pub default_value: Option<LexLiteral>,
}

// ============================================================================
// PATTERN MATCHING
// ============================================================================

/// Pattern matching arm in match expressions.
///
/// Represents a single branch in a pattern matching expression,
/// containing the pattern to match and the instructions to execute
/// when the pattern matches.
///
/// # Example
/// ```rust
/// use lexc::lexir::LexMatchArm;
///
/// let arm = LexMatchArm {
///     pattern: "Some(x)".to_string(),
///     body: vec![], // Instructions for this pattern
/// };
/// ```
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct LexMatchArm {
    /// Pattern to match (simplified as string for now)
    pub pattern: String,
    /// Instructions to execute when pattern matches
    pub body: Vec<LexInstruction>,
}

// ============================================================================
// ASYNC OPERATIONS
// ============================================================================

/// Parameters for individual async ask operations.
///
/// Used in parallel async operations to specify the parameters
/// for each individual LLM call.
///
/// # Example
/// ```rust
/// use lexc::lexir::AsyncAskParams;
/// use std::collections::HashMap;
///
/// let params = AsyncAskParams {
///     system_prompt: Some("You are a helpful assistant".to_string()),
///     user_prompt: Some("What is the capital of France?".to_string()),
///     model: Some("gpt-4".to_string()),
///     temperature: Some(0.7),
///     max_tokens: Some(100),
///     schema: None,
///     attributes: HashMap::new(),
/// };
/// ```
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AsyncAskParams {
    /// Optional system prompt
    pub system_prompt: Option<String>,
    /// Optional user prompt
    pub user_prompt: Option<String>,
    /// Optional model override
    pub model: Option<String>,
    /// Optional temperature (0.0-2.0)
    pub temperature: Option<f64>,
    /// Optional maximum tokens
    pub max_tokens: Option<u32>,
    /// Optional JSON schema for response validation
    pub schema: Option<String>,
    /// Additional provider-specific attributes
    pub attributes: HashMap<String, String>,
}

// ============================================================================
// INSTRUCTIONS
// ============================================================================

/// Executable instructions in LexIR.
///
/// Instructions represent the atomic operations that can be performed
/// during program execution. They are organized into logical categories:
///
/// ## Core Operations
/// - [`Assign`]: Variable assignment
/// - [`Declare`]: Variable declaration
/// - [`Call`]: Function calls
/// - [`Return`]: Function returns
///
/// ## Control Flow
/// - [`If`]: Conditional execution
/// - [`While`]: While loops
/// - [`ForEach`]: Iterator loops
/// - [`Break`], [`Continue`]: Loop control
/// - [`Match`]: Pattern matching
///
/// ## Data Operations
/// - [`DataLoad`]: Load external data
/// - [`DataFilter`]: Filter datasets
/// - [`DataSelect`]: Select columns
/// - [`DataTake`]: Take N rows
/// - [`DataExport`]: Export data
/// - [`DataFlatten`]: Flatten nested data
/// - [`DataFilterJsonPath`]: JSONPath filtering
/// - [`DataInferSchema`]: Schema inference
/// - [`DataValidateIncremental`]: Incremental validation
///
/// ## LLM Operations
/// - [`Ask`]: Standard LLM calls
/// - [`AskSafe`]: Anti-hallucination LLM calls
/// - [`AsyncAsk`]: Asynchronous LLM calls
/// - [`AsyncAskParallel`]: Parallel LLM calls
///
/// ## Memory Operations
/// - [`MemoryLoad`]: Load from contextual memory
/// - [`MemoryStore`]: Store to contextual memory
///
/// # Example
/// ```rust
/// use lexc::lexir::{LexInstruction, ValueRef, LexExpression, LexLiteral};
///
/// let instruction = LexInstruction::Assign {
///     result: ValueRef::Named("x".to_string()),
///     expr: LexExpression::Value(ValueRef::Literal(LexLiteral::Integer(42))),
/// };
/// ```
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum LexInstruction {
    // ------------------------------------------------------------------------
    // CORE OPERATIONS
    // ------------------------------------------------------------------------
    /// Assigns a value to a variable.
    ///
    /// This is the fundamental operation for storing computation results.
    /// The expression is evaluated and its result is stored in the target variable.
    ///
    /// # Example
    /// ```lexon
    /// let x = 42;           // Assign literal
    /// let y = x + 1;        // Assign expression result
    /// let z = ask("Hello"); // Assign LLM result
    /// ```
    Assign {
        /// Target variable or temporary
        result: ValueRef,
        /// Expression to evaluate and assign
        expr: LexExpression,
    },

    /// Declares a variable with optional type and mutability.
    ///
    /// Variable declarations establish the binding between a name and
    /// a memory location, with optional type annotation.
    ///
    /// # Example
    /// ```lexon
    /// let x: int;           // Immutable integer
    /// let mut y: string;    // Mutable string
    /// let z;                // Type inferred
    /// ```
    Declare {
        /// Variable name
        name: String,
        /// Optional type annotation
        type_name: Option<String>,
        /// Whether the variable is mutable
        is_mutable: bool,
    },

    /// Calls a function with arguments.
    ///
    /// Function calls can be used for both built-in functions and
    /// user-defined functions. The result can be optionally captured.
    ///
    /// # Example
    /// ```lexon
    /// print("Hello");       // Call without result
    /// let x = add(1, 2);    // Call with result
    /// ```
    Call {
        /// Optional result destination
        result: Option<ValueRef>,
        /// Function name to call
        function: String,
        /// Arguments to pass
        args: Vec<LexExpression>,
    },

    /// Returns a value from a function.
    ///
    /// Function returns transfer control back to the caller with
    /// an optional return value.
    ///
    /// # Example
    /// ```lexon
    /// return 42;            // Return value
    /// return;               // Return void
    /// ```
    Return {
        /// Optional return expression
        expr: Option<LexExpression>,
    },

    // ------------------------------------------------------------------------
    // CONTROL FLOW
    // ------------------------------------------------------------------------
    /// Conditional execution based on a boolean expression.
    ///
    /// If statements provide branching logic with optional else blocks.
    /// The condition is evaluated and execution proceeds accordingly.
    ///
    /// # Example
    /// ```lexon
    /// if (x > 0) {
    ///     print("positive");
    /// } else {
    ///     print("non-positive");
    /// }
    /// ```
    If {
        /// Condition to evaluate
        condition: LexExpression,
        /// Instructions to execute if true
        then_block: Vec<LexInstruction>,
        /// Optional instructions to execute if false
        else_block: Option<Vec<LexInstruction>>,
    },

    /// While loop with continuation condition.
    ///
    /// Executes the loop body repeatedly while the condition remains true.
    /// The condition is evaluated before each iteration.
    ///
    /// # Example
    /// ```lexon
    /// let i = 0;
    /// while (i < 10) {
    ///     print(i);
    ///     i = i + 1;
    /// }
    /// ```
    While {
        /// Condition to check before each iteration
        condition: LexExpression,
        /// Instructions to execute in each iteration
        body: Vec<LexInstruction>,
    },

    /// For-each loop over an iterable collection.
    ///
    /// Iterates over each element in a collection, binding each element
    /// to the iterator variable for use within the loop body.
    ///
    /// # Example
    /// ```lexon
    /// for item in items {
    ///     print(item);
    /// }
    /// ```
    ForEach {
        /// Iterator variable name
        iterator: String,
        /// Collection to iterate over
        iterable: ValueRef,
        /// Instructions to execute for each element
        body: Vec<LexInstruction>,
    },

    /// Breaks out of the current loop.
    ///
    /// Immediately exits the innermost loop, transferring control
    /// to the instruction following the loop.
    ///
    /// # Example
    /// ```lexon
    /// while (true) {
    ///     if (should_exit) break;
    /// }
    /// ```
    Break,

    /// Continues to the next iteration of the current loop.
    ///
    /// Skips the remaining instructions in the current loop iteration
    /// and proceeds to the next iteration.
    ///
    /// # Example
    /// ```lexon
    /// for i in range(10) {
    ///     if (i % 2 == 0) continue;
    ///     print(i);  // Only odd numbers
    /// }
    /// ```
    Continue,

    /// Pattern matching with multiple branches.
    ///
    /// Evaluates the value against multiple patterns and executes
    /// the first matching branch.
    ///
    /// # Example
    /// ```lexon
    /// match result {
    ///     Ok(value) => print(value),
    ///     Err(error) => print("Error: " + error),
    /// }
    /// ```
    Match {
        /// Value to match against patterns
        value: LexExpression,
        /// List of pattern-action pairs
        arms: Vec<LexMatchArm>,
    },

    /// Load data from external source
    DataLoad {
        /// Reference to result
        result: ValueRef,
        /// Data source (path or URI)
        source: String,
        /// Optional schema for validation
        schema: Option<String>,
        /// Additional options
        options: HashMap<String, LexLiteral>,
    },

    /// Filter rows from a dataset
    DataFilter {
        /// Reference to result
        result: ValueRef,
        /// Input dataset
        input: ValueRef,
        /// Predicate (filter condition)
        predicate: LexExpression,
    },

    /// Select specific columns
    DataSelect {
        /// Reference to result
        result: ValueRef,
        /// Input dataset
        input: ValueRef,
        /// Columns to select
        fields: Vec<String>,
    },

    /// Take N rows from a dataset
    DataTake {
        /// Reference to result
        result: ValueRef,
        /// Input dataset
        input: ValueRef,
        /// Number of rows to take
        count: ValueRef,
    },

    /// Export a dataset to a file
    DataExport {
        /// Dataset to export
        input: ValueRef,
        /// Destination path
        path: String,
        /// Export format
        format: String,
        /// Additional options
        options: HashMap<String, LexLiteral>,
    },

    /// Flatten nested fields
    DataFlatten {
        /// Reference to result
        result: ValueRef,
        /// Input dataset
        input: ValueRef,
        /// Optional separator
        separator: Option<String>,
    },

    /// Filter dataset using JSONPath
    DataFilterJsonPath {
        /// Reference to result
        result: ValueRef,
        /// Input dataset
        input: ValueRef,
        /// JSONPath expression
        path: String,
    },

    /// Infer JSON schema from a dataset
    DataInferSchema {
        /// Reference to result
        result: ValueRef,
        /// Input dataset
        input: ValueRef,
    },

    /// Incremental schema validation
    DataValidateIncremental {
        /// Reference to result
        result: ValueRef,
        /// Dataset to validate
        input: ValueRef,
        /// JSON schema
        schema: ValueRef,
    },

    /// Perform a LLM call (ask)
    Ask {
        /// Destination of result
        result: ValueRef,
        /// Optional system prompt
        system_prompt: Option<String>,
        /// Optional user prompt
        user_prompt: Option<String>,
        /// Optional model
        model: Option<String>,
        /// Optional temperature
        temperature: Option<f64>,
        /// Optional maximum tokens
        max_tokens: Option<u32>,
        /// Optional JSON schema for response validation
        schema: Option<String>,
        /// Additional attributes
        attributes: HashMap<String, String>,
    },

    /// üõ°Ô∏è Perform a LLM call with hallucination prevention (ask_safe)
    AskSafe {
        /// Destination of result
        result: ValueRef,
        /// Optional system prompt
        system_prompt: Option<String>,
        /// Optional user prompt
        user_prompt: Option<String>,
        /// Optional model
        model: Option<String>,
        /// Optional temperature
        temperature: Option<f64>,
        /// Optional maximum tokens
        max_tokens: Option<u32>,
        /// Optional JSON schema for response validation
        schema: Option<String>,
        /// Additional attributes
        attributes: HashMap<String, String>,
        /// Validation strategy ("basic", "ensemble", "fact_check", "comprehensive")
        validation_strategy: Option<String>,
        /// Confidence threshold (0.0-1.0)
        confidence_threshold: Option<f64>,
        /// Maximum number of validation attempts
        max_attempts: Option<u32>,
        /// Models for cross-validation
        cross_reference_models: Vec<String>,
        /// Use fact checking
        use_fact_checking: Option<bool>,
    },

    /// Perform an asynchronous LLM call (await ask)
    AsyncAsk {
        /// Destination of result
        result: ValueRef,
        /// Optional system prompt
        system_prompt: Option<String>,
        /// Optional user prompt
        user_prompt: Option<String>,
        /// Optional model
        model: Option<String>,
        /// Optional temperature
        temperature: Option<f64>,
        /// Optional maximum tokens
        max_tokens: Option<u32>,
        /// Optional JSON schema for response validation
        schema: Option<String>,
        /// Additional attributes
        attributes: HashMap<String, String>,
        /// Unique ID for async task tracking
        task_id: Option<String>,
    },

    /// Perform multiple asks in parallel (Promise.all)
    AsyncAskParallel {
        /// List of result destinations (one per ask)
        results: Vec<ValueRef>,
        /// List of asks to execute in parallel
        asks: Vec<AsyncAskParams>,
        /// Optional timeout in milliseconds
        timeout_ms: Option<u64>,
        /// Maximum concurrent asks
        max_concurrent: Option<usize>,
    },

    /// Load data from contextual memory
    MemoryLoad {
        /// Reference to result
        result: ValueRef,
        /// Memory scope
        scope: String,
        /// Optional source to add to context
        source: Option<ValueRef>,
        /// Memory strategy ("buffer", "vector", "summary")
        strategy: String,
        /// Additional options (capacity, key, etc.)
        options: HashMap<String, LexLiteral>,
    },

    /// Store data in contextual memory
    MemoryStore {
        /// Memory scope
        scope: String,
        /// Value to store
        value: ValueRef,
        /// Optional key for direct access
        key: Option<String>,
        /// Additional options
        options: HashMap<String, LexLiteral>,
    },
}

/// LexIR expression type
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum LexExpression {
    /// Simple value reference
    Value(ValueRef),

    /// Binary operation
    BinaryOp {
        operator: LexBinaryOperator,
        left: Box<LexExpression>,
        right: Box<LexExpression>,
    },

    /// Unary operation
    UnaryOp {
        operator: LexUnaryOperator,
        operand: Box<LexExpression>,
    },

    /// Field access
    FieldAccess {
        base: Box<LexExpression>,
        field: String,
    },
}

/// Binary operators
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub enum LexBinaryOperator {
    Add,
    Subtract,
    Multiply,
    Divide,
    GreaterThan,
    LessThan,
    GreaterEqual,
    LessEqual,
    Equal,
    NotEqual,
    And,
    Or,
}

/// Unary operators
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub enum LexUnaryOperator {
    Negate,
    Not,
}

impl LexProgram {
    /// Create a new empty LexIR program
    pub fn new() -> Self {
        LexProgram {
            instructions: Vec::new(),
            types: HashMap::new(),
            schemas: HashMap::new(),
            functions: HashMap::new(),
        }
    }

    /// Add an instruction to the program
    pub fn add_instruction(&mut self, instruction: LexInstruction) {
        self.instructions.push(instruction);
    }

    /// Add a schema definition
    pub fn add_schema(&mut self, schema: LexSchemaDefinition) {
        self.schemas.insert(schema.name.clone(), schema);
    }

    /// Add a function definition
    pub fn add_function(&mut self, function: LexFunction) {
        self.functions.insert(function.name.clone(), function);
    }

    /// Export LexIR program to JSON
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(self)
    }

    /// Load LexIR program from JSON
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        serde_json::from_str(json)
    }
}

impl Default for LexProgram {
    fn default() -> Self {
        Self::new()
    }
}
