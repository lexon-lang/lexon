use clap::Parser as ClapParser; // Rename to avoid conflict with tree_sitter::Parser
use lexc::executor::{ExecutionEnvironment, ExecutorConfig};
use lexc::lex_executor::{HybridExecutor, LexExecutor};
use lexc::lexir::LexProgram;
use lexc::linter::lint_hir;
use lexc::optimizer::{Optimizer, OptimizerConfig};
// use lexc::runtime::RuntimeConfig;
use lexc::{hir_builder, hir_to_lexir}; // Removed semantic module
use std::fs;
use std::path::PathBuf;
use std::time::Instant;
use tokio::runtime::Runtime as TokioRuntime;
use tree_sitter::Parser; // Add linter import

// Declaration to link with the C function generated by tree-sitter and compiled by build.rs
// The function name must match what tree-sitter generates for your grammar (tree_sitter_<grammar_name>)
extern "C" {
    fn tree_sitter_lexon() -> tree_sitter::Language;
}

/// LEXON Compiler - Professional CLI
/// Compile and execute LEXON programs with advanced features
#[derive(ClapParser)]
#[command(name = "lexc")]
#[command(about = "LEXON Compiler - Professional development tool for LEXON programs")]
#[command(version = "1.0.0")]
#[command(long_about = "
LEXON Compiler v1.0 - Professional CLI

USAGE:
    lexc [OPTIONS] <INPUT_FILE>
    lexc --repl                    # Interactive REPL mode
    lexc --version                 # Show version information

EXAMPLES:
    lexc program.lx                # Compile and execute
    lexc --check program.lx        # Syntax check only
    lexc --output program.ir program.lx  # Export compiled IR
    lexc --benchmark program.lx    # Performance benchmarking
    lexc --repl                    # Interactive mode
")]
struct Cli {
    /// Input LEXON file to compile and execute
    #[arg(value_name = "INPUT_FILE")]
    input_file: Option<PathBuf>,

    /// Only check syntax without executing
    #[arg(short = 'c', long = "check")]
    check_only: bool,

    /// Export compiled IR to file
    #[arg(short = 'o', long = "output")]
    output_ir: Option<PathBuf>,

    /// Load and execute from pre-compiled IR file
    #[arg(long = "load-ir")]
    load_ir: Option<PathBuf>,

    /// Run performance benchmark
    #[arg(short = 'b', long = "benchmark")]
    benchmark: bool,

    /// Start interactive REPL mode
    #[arg(long = "repl")]
    repl: bool,

    /// Enable verbose output
    #[arg(short = 'v', long = "verbose")]
    verbose: bool,

    /// Disable optimizations
    #[arg(long = "no-opt")]
    no_optimization: bool,

    /// Set LLM model for execution
    #[arg(long = "model", default_value = "gpt-4")]
    llm_model: String,

    /// Set LLM temperature (0.0-1.0)
    #[arg(long = "temperature", default_value = "0.7")]
    temperature: f32,

    /// Run linter to detect async/await issues
    #[arg(long)]
    lint: bool,
}

fn main() {
    let args = Cli::parse();

    // Initialize optional OpenTelemetry tracing if enabled and requested
    #[cfg(feature = "otel")]
    {
        let _ = lexc::telemetry::init_tracing();
    }

    // Handle REPL mode
    if args.repl {
        println!("üöÄ LEXON Interactive REPL v1.0");
        println!("Type 'exit' to quit, 'help' for commands");
        run_repl();
        return;
    }

    // Require input file for all operations except --load-ir
    if args.input_file.is_none() && args.load_ir.is_none() {
        eprintln!("‚ùå Error: Input file required");
        eprintln!("Usage: lexc <INPUT_FILE>");
        eprintln!("       lexc --load-ir <IR_FILE>");
        eprintln!("       lexc --repl");
        eprintln!("Try 'lexc --help' for more information");
        std::process::exit(1);
    }

    // Create Tokio runtime
    let tokio_rt = TokioRuntime::new().unwrap();

    // Handle different modes
    let result = if args.check_only {
        // Syntax check only
        check_syntax(&args, &tokio_rt)
    } else if args.lint {
        // Run linter
        run_linter(&args, &tokio_rt)
    } else if args.benchmark {
        // Performance benchmark
        run_benchmark(&args, &tokio_rt)
    } else {
        // Normal compile and run
        compile_and_run(&args, &tokio_rt)
    };

    match result {
        Ok(Some(exec_time)) => {
            if args.verbose {
                println!("‚úÖ Execution completed in {:.2}ms", exec_time);
            }
        }
        Ok(None) => {
            if args.verbose {
                println!("‚úÖ Compilation completed successfully");
            }
        }
        Err(e) => {
            eprintln!("‚ùå Error: {}", e);
            std::process::exit(1);
        }
    }
}

#[allow(dead_code)]
fn mean(data: &[f64]) -> f64 {
    if data.is_empty() {
        0.0
    } else {
        data.iter().sum::<f64>() / data.len() as f64
    }
}

#[allow(dead_code)]
fn median(mut data: Vec<f64>) -> f64 {
    if data.is_empty() {
        return 0.0;
    }
    data.sort_by(|a, b| a.partial_cmp(b).unwrap());
    let n = data.len();
    if n % 2 == 0 {
        (data[n / 2 - 1] + data[n / 2]) / 2.0
    } else {
        data[n / 2]
    }
}

#[allow(dead_code)]
fn stddev(data: &[f64]) -> f64 {
    if data.len() <= 1 {
        return 0.0;
    }
    let mean_val = mean(data);
    let variance =
        data.iter().map(|x| (x - mean_val).powi(2)).sum::<f64>() / (data.len() as f64 - 1.0);
    variance.sqrt()
}

// Compiles the program and returns Ok(Some(exec_time_ms)) if executed
// or Ok(None) if not executed. Returns Err(msg) on failure.
fn compile_and_run(args: &Cli, _tokio_rt: &TokioRuntime) -> Result<Option<f64>, String> {
    // --- 1. Load or compile to LexIR ---
    let mut program: LexProgram;

    if let Some(ir_path) = &args.load_ir {
        // Load from IR JSON file
        let json_content = fs::read_to_string(ir_path)
            .map_err(|e| format!("Failed to read IR file {}: {}", ir_path.display(), e))?;
        program = LexProgram::from_json(&json_content)
            .map_err(|e| format!("Failed to parse IR JSON: {}", e))?;
    } else {
        // Compile from source
        let input_file = args
            .input_file
            .as_ref()
            .ok_or_else(|| "Input file required when not using --load-ir".to_string())?;

        let source_code = fs::read_to_string(input_file)
            .map_err(|e| format!("Failed to read input file {}: {}", input_file.display(), e))?;

        // Parse with tree-sitter
        let mut parser = Parser::new();
        let language = unsafe { tree_sitter_lexon() };
        parser
            .set_language(&language)
            .map_err(|e| format!("Failed to set parser language: {}", e))?;

        let tree = parser
            .parse(&source_code, None)
            .ok_or_else(|| "Failed to parse source code".to_string())?;

        if args.verbose {
            println!("‚úÖ Parsed successfully");
        }

        // Build HIR
        let hir = hir_builder::build_hir_from_cst(tree.root_node(), &source_code)
            .map_err(|e| format!("HIR build error: {:?}", e))?;

        if args.verbose {
            println!("‚úÖ HIR built successfully");
            println!("üîç DEBUG: HIR nodes: {:?}", hir);
        }

        // Convert to LexIR
        program = hir_to_lexir::convert_hir_to_lexir(&hir)
            .map_err(|e| format!("HIR to LexIR conversion error: {:?}", e))?;

        if args.verbose {
            println!("‚úÖ LexIR generated successfully");
        }
    }

    // --- 2. Apply optimizations if requested ---
    // Note: Optimizations are disabled by default to match lexc-cli behavior
    // Use --optimize flag to enable optimizations
    if false {
        // Disabled for now to fix regression
        let optimizer = Optimizer::new(OptimizerConfig::default());

        // Note: The optimizer operates on &mut LexProgram, not returning a new one
        optimizer
            .optimize(&mut program)
            .map_err(|e| format!("Optimization error: {:?}", e))?;

        if args.verbose {
            println!("‚úÖ Optimizations applied");
        }
    }

    // --- 3. Export IR if requested ---
    if let Some(export_path) = &args.output_ir {
        let json_output = program
            .to_json()
            .map_err(|e| format!("Failed to serialize program to JSON: {}", e))?;

        fs::write(export_path, json_output)
            .map_err(|e| format!("Failed to write IR to {}: {}", export_path.display(), e))?;

        if args.verbose {
            println!("‚úÖ IR exported to {}", export_path.display());
        }
    }

    // --- 4. Check mode: validate and exit ---
    if args.check_only {
        println!("‚úÖ Syntax and semantic checks passed");
        return Ok(None);
    }

    // --- 5. Execute the program ---
    let should_run = !args.check_only && (args.input_file.is_some() || args.load_ir.is_some());

    if should_run {
        if args.verbose {
            println!("üöÄ Executing program...");
        }

        // Execute synchronously for now
        execute_synchronous(&program, args)?;
        return Ok(Some(0.0)); // Placeholder execution time
    }

    Ok(None)
}

fn execute_synchronous(program: &LexProgram, args: &Cli) -> Result<(), String> {
    // Create executor config using the same pattern as the working lexc-cli
    let executor_config = ExecutorConfig {
        memory_path: None,
        verbose: args.verbose,
        llm_model: Some(args.llm_model.clone()),
        use_new_llm_architecture: true, // Use new architecture by default
        llm_mode: Some("auto".to_string()), // Automatic mode
    };

    // Create HybridExecutor like in the working lexc-cli
    let mut executor = HybridExecutor::Sync(ExecutionEnvironment::new(executor_config));

    // Create Tokio runtime for async execution
    let rt = TokioRuntime::new().unwrap();

    // Execute using the same pattern as lexc-cli
    let res = rt.block_on(async { executor.execute_program_generic(program).await });
    res.map_err(|e| format!("Execution error: {}", e))?;

    Ok(())
}

#[allow(dead_code)]
fn execute_with_async_runtime(program: &LexProgram, args: &Cli, _tokio_rt: &TokioRuntime) {
    // Async execution implementation would go here
    // For now, fall back to synchronous execution
    if let Err(e) = execute_synchronous(program, args) {
        eprintln!("Async execution failed: {}", e);
    }
}

// Helper function for interactive REPL mode
fn run_repl() {
    use std::io::{self, Write};

    println!("üìñ LEXON Interactive REPL");
    println!("Commands:");
    println!("  help    - Show this help");
    println!("  exit    - Exit REPL");
    println!("  clear   - Clear screen");
    println!("  version - Show version");
    println!();

    let _tokio_rt = TokioRuntime::new().unwrap();

    loop {
        print!("lexon> ");
        io::stdout().flush().unwrap();

        let mut input = String::new();
        match io::stdin().read_line(&mut input) {
            Ok(_) => {
                let input = input.trim();

                match input {
                    "exit" | "quit" => {
                        println!("üëã Goodbye!");
                        break;
                    }
                    "help" => {
                        println!("üìñ Available commands:");
                        println!("  help    - Show this help");
                        println!("  exit    - Exit REPL");
                        println!("  clear   - Clear screen");
                        println!("  version - Show version");
                        println!("  Or enter LEXON code to execute");
                    }
                    "clear" => {
                        print!("\x1B[2J\x1B[1;1H");
                    }
                    "version" => {
                        println!("LEXON Compiler v1.0.0");
                    }
                    "" => continue,
                    _ => {
                        // Try to execute as LEXON code
                        println!("üîß REPL execution not yet implemented");
                        println!("üí° Use 'lexc file.lx' to run LEXON programs");
                    }
                }
            }
            Err(e) => {
                eprintln!("Error reading input: {}", e);
                break;
            }
        }
    }
}

// Helper function for syntax checking only
fn check_syntax(args: &Cli, _tokio_rt: &TokioRuntime) -> Result<Option<f64>, String> {
    let input_file = args.input_file.as_ref().unwrap();

    if args.verbose {
        println!("üîç Checking syntax: {}", input_file.display());
    }

    // Read source code
    let source_code = fs::read_to_string(input_file)
        .map_err(|e| format!("Failed to read file {}: {}", input_file.display(), e))?;

    // Parse with tree-sitter
    let mut parser = Parser::new();
    let language = unsafe { tree_sitter_lexon() };
    parser
        .set_language(&language)
        .map_err(|e| format!("Failed to set language: {}", e))?;

    let tree = parser
        .parse(&source_code, None)
        .ok_or_else(|| "Parse error".to_string())?;

    // Build HIR for deeper analysis
    let hir = hir_builder::build_hir_from_cst(tree.root_node(), &source_code)
        .map_err(|e| format!("HIR error: {:?}", e))?;

    if args.verbose {
        println!("‚úÖ Syntax check passed ({} HIR nodes)", hir.len());
    }

    // Run linter if --lint flag is provided
    if args.lint {
        if args.verbose {
            println!("üîç Running linter analysis...");
        }

        let lint_result = lint_hir(&hir);

        if lint_result.warnings.is_empty() && lint_result.errors.is_empty() {
            println!("‚úÖ No linting issues found");
        } else {
            if !lint_result.warnings.is_empty() {
                println!("‚ö†Ô∏è  Linting Warnings:");
                for warning in &lint_result.warnings {
                    match warning {
                        lexc::linter::LintWarning::MissingAwait {
                            function_name,
                            line,
                            message,
                        } => {
                            println!(
                                "  Warning: Missing await for '{}' at line {}",
                                function_name, line
                            );
                            println!("    {}", message);
                        }
                        lexc::linter::LintWarning::BlockingIoInAsync {
                            operation,
                            line,
                            message,
                        } => {
                            println!("  Warning: Blocking I/O '{}' at line {}", operation, line);
                            println!("    {}", message);
                        }
                        lexc::linter::LintWarning::AsyncFunctionNotAwaited {
                            function_name,
                            line,
                            message,
                        } => {
                            println!(
                                "  Warning: Async function '{}' not awaited at line {}",
                                function_name, line
                            );
                            println!("    {}", message);
                        }
                        lexc::linter::LintWarning::SyncCallInAsyncContext {
                            function_name,
                            line,
                            message,
                        } => {
                            println!(
                                "  Warning: Sync call '{}' in async context at line {}",
                                function_name, line
                            );
                            println!("    {}", message);
                        }
                    }
                }
            }

            if !lint_result.errors.is_empty() {
                println!("‚ùå Linting Errors:");
                for error in &lint_result.errors {
                    println!("  Error: {}", error);
                }
            }
        }

        if args.verbose {
            println!("‚úÖ Linter analysis completed");
        }
    }

    Ok(None)
}

// Helper function for performance benchmarking
fn run_benchmark(args: &Cli, _tokio_rt: &TokioRuntime) -> Result<Option<f64>, String> {
    let input_file = args.input_file.as_ref().unwrap();

    println!("üèÉ Running benchmark: {}", input_file.display());
    println!("üìä Iterations: 10");

    let mut times = Vec::new();

    for i in 1..=10 {
        if args.verbose {
            println!("  Run {}/10...", i);
        }

        let start = Instant::now();
        let result = compile_and_run(args, _tokio_rt);
        let duration = start.elapsed();

        match result {
            Ok(_) => {
                times.push(duration.as_secs_f64() * 1000.0);
            }
            Err(e) => {
                return Err(format!("Benchmark failed on iteration {}: {}", i, e));
            }
        }
    }

    // Calculate statistics
    let total: f64 = times.iter().sum();
    let avg = total / times.len() as f64;
    let min = times.iter().fold(f64::INFINITY, |a, &b| a.min(b));
    let max = times.iter().fold(f64::NEG_INFINITY, |a, &b| a.max(b));

    println!("üìà Benchmark Results:");
    println!("  Average: {:.2}ms", avg);
    println!("  Minimum: {:.2}ms", min);
    println!("  Maximum: {:.2}ms", max);
    println!("  Total:   {:.2}ms", total);

    Ok(Some(avg))
}

// Helper function for linting only
fn run_linter(args: &Cli, _tokio_rt: &TokioRuntime) -> Result<Option<f64>, String> {
    let input_file = args.input_file.as_ref().unwrap();

    if args.verbose {
        println!("üîç Running linter on: {}", input_file.display());
    }

    // Read source code
    let source_code = fs::read_to_string(input_file)
        .map_err(|e| format!("Failed to read file {}: {}", input_file.display(), e))?;

    // Parse with tree-sitter
    let mut parser = Parser::new();
    let language = unsafe { tree_sitter_lexon() };
    parser
        .set_language(&language)
        .map_err(|e| format!("Failed to set language: {}", e))?;

    let tree = parser
        .parse(&source_code, None)
        .ok_or_else(|| "Parse error".to_string())?;

    // Build HIR for linting
    let hir_nodes = hir_builder::build_hir_from_cst(tree.root_node(), &source_code)
        .map_err(|e| format!("HIR build error: {:?}", e))?;

    if args.verbose {
        println!("‚úÖ HIR built successfully ({} nodes)", hir_nodes.len());
    }

    // Run linter
    let lint_result = lint_hir(&hir_nodes);

    // Print results
    if lint_result.warnings.is_empty() && lint_result.errors.is_empty() {
        println!("‚úÖ No linting issues found");
    } else {
        if !lint_result.warnings.is_empty() {
            println!("‚ö†Ô∏è  Linting Warnings:");
            for warning in &lint_result.warnings {
                match warning {
                    lexc::linter::LintWarning::MissingAwait {
                        function_name,
                        line,
                        message,
                    } => {
                        println!(
                            "  Warning: Missing await for '{}' at line {}",
                            function_name, line
                        );
                        println!("    {}", message);
                    }
                    lexc::linter::LintWarning::BlockingIoInAsync {
                        operation,
                        line,
                        message,
                    } => {
                        println!("  Warning: Blocking I/O '{}' at line {}", operation, line);
                        println!("    {}", message);
                    }
                    lexc::linter::LintWarning::AsyncFunctionNotAwaited {
                        function_name,
                        line,
                        message,
                    } => {
                        println!(
                            "  Warning: Async function '{}' not awaited at line {}",
                            function_name, line
                        );
                        println!("    {}", message);
                    }
                    lexc::linter::LintWarning::SyncCallInAsyncContext {
                        function_name,
                        line,
                        message,
                    } => {
                        println!(
                            "  Warning: Sync call '{}' in async context at line {}",
                            function_name, line
                        );
                        println!("    {}", message);
                    }
                }
            }
        }

        if !lint_result.errors.is_empty() {
            println!("‚ùå Linting Errors:");
            for error in &lint_result.errors {
                println!("  Error: {}", error);
            }
        }
    }

    Ok(None)
}

// You might have modules like:
// mod lex_cli;      // For CLI argument parsing
// mod lex_parser;   // For tree-sitter parser logic
// mod lex_ast;      // For AST (Hir) definitions
// mod lex_semantics; // For semantic analysis
